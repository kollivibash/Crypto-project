# =====================================
# ETHEREUM PRICE PREDICTION (LOCAL)
# =====================================

import pandas as pd
import numpy as np
import math
import yfinance as yf
import plotly.express as px

from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error
from xgboost import XGBRegressor
from itertools import cycle

# =========================
# DOWNLOAD DATA
# =========================

print("Downloading Ethereum data...")

df = yf.download("ETH-USD", start="2017-01-01", end="2025-01-01")
df.reset_index(inplace=True)

df = df[['Date', 'Close']]
df.columns = ['date', 'close']

print("Data downloaded successfully!")
print(df.head())

# =========================
# PREPROCESSING
# =========================

scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(df[['close']])

training_size = int(len(scaled_data) * 0.70)
train_data = scaled_data[:training_size]
test_data = scaled_data[training_size:]

# =========================
# CREATE DATASET FUNCTION
# =========================

def create_dataset(dataset, time_step=15):
    X, y = [], []
    for i in range(len(dataset) - time_step - 1):
        X.append(dataset[i:(i + time_step), 0])
        y.append(dataset[i + time_step, 0])
    return np.array(X), np.array(y)

time_step = 15

X_train, y_train = create_dataset(train_data, time_step)
X_test, y_test = create_dataset(test_data, time_step)

# =========================
# TRAIN MODEL
# =========================

model = XGBRegressor(
    n_estimators=500,
    learning_rate=0.05,
    max_depth=6
)

model.fit(X_train, y_train)

# =========================
# PREDICTION
# =========================

train_predict = model.predict(X_train)
test_predict = model.predict(X_test)

print("MAE:", mean_absolute_error(y_test, test_predict))
print("RMSE:", math.sqrt(mean_squared_error(y_test, test_predict)))

# Inverse transform
train_predict = scaler.inverse_transform(train_predict.reshape(-1, 1))
test_predict = scaler.inverse_transform(test_predict.reshape(-1, 1))

# =========================
# PLOT ACTUAL VS PREDICTED
# =========================

plot_df = pd.DataFrame({
    "date": df['date'][training_size + time_step + 1:],
    "Actual": scaler.inverse_transform(y_test.reshape(-1,1)).flatten(),
    "Predicted": test_predict.flatten()
})

fig = px.line(plot_df, x="date", y=["Actual", "Predicted"],
              title="Ethereum Actual vs Predicted Price")

fig.show()

# =========================
# FUTURE 10 DAYS PREDICTION
# =========================

x_input = test_data[-time_step:].reshape(1, -1)
temp_input = list(x_input[0])

future_predictions = []

for i in range(10):
    x_input = np.array(temp_input[-time_step:]).reshape(1, -1)
    yhat = model.predict(x_input)
    temp_input.append(yhat[0])
    future_predictions.append(yhat[0])

future_predictions = scaler.inverse_transform(
    np.array(future_predictions).reshape(-1, 1)
)

print("\nNext 10 Days Prediction:")
print(future_predictions.flatten())
